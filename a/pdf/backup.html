<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Skill By PM (Made In India)</title>
    <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>



    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        .searchPanel {

            width: 150px;
        }

        .sidebar {
            width: 20%;
            background: #f4f4f4;
            padding: 5px;
            overflow-y: auto;
            border-right: 2px solid #ddd;
            flex-shrink: 0;


        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar li {
            padding: 5px 0;
            cursor: pointer;
            /* transition: background 0.3s; */
        }



        .pdf-viewer {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        #tabHeaders {
            display: flex;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            border-bottom: 2px solid #18c7d400;
            padding: 10px;
            max-width: 70%;
            margin-right: 30px;
            height: 50px;
            
            /* scrollbar-width: thin; */
        }

        #tabHeaders::-webkit-scrollbar {
            height: 8px;
        }

        #tabHeaders::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .tabs-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #c2c2c2;
            border: 2px solid #3498db;
           
            height: 30px;
        }

        .tab {
            padding: 10px 10px;
            margin-right: 5px;
            background: #728db6;
            border-radius: 18px 0px 18px 0px;
            cursor: pointer;
            display: flex;
            align-items: center;
            flex-shrink: 0;
            border: 1px solid #000;
        }

        .tab.active {
            background: #3498db;
            color: white;
        }

        .close-btn {
            margin-left: 10px;
            cursor: pointer;
            font-weight: bold;
        }

      

        #pdf-ui {
            overflow-y: auto;
            flex-grow: 1;
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            padding: 20px;
        }


        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
            display: none;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #categoryList {
            margin-top: 20px;
        }

        /* Tree styling */
        .tree {
            list-style-type: none;
            padding-left: 20px;
        }

        .tree li {
            margin: 5px 0;
        }

        #sidebar ul {
            margin: 0;
            padding-left: 20px;
            list-style: none;
            line-height: 1em;
        }

        #sidebar ul li {
            position: relative;
        }

        #sidebar ul li::before,
        #sidebar ul li::after {
            content: "";
            position: absolute;
            left: -15px;
            border-left: 2px dashed #999;
        }

        #sidebar ul li::before {
            top: 0;
            width: 15px;
            height: 1em;
            border-bottom: 2px dashed #999;
        }

        #sidebar ul.tree>li:first-child::before {
            border-left: none;
        }

        #sidebar ul li::after {
            top: 1.1em;
            bottom: 1px;
        }

        #sidebar ul li:last-child::after {
            display: none;
        }

        .bxs-file-pdf {
            color: gray;
            /* PDF icon color */
            margin-right: 5px;
        }


        #pdfContainers {
            position: relative;
            width: 100%;
            height: 100vh;
            /* Full screen height */
            border: 2px solid #3498db;
            overflow: hidden;
            display: flex;
            /* Optional: only if you want to center content */

        }

        #pdfContainers img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            /* Ensures the image scales nicely */
        }

        .pdf-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            /* Hide by default */
        }

        .pdf-container.active {
            display: block;
            /* Show only the active PDF */
        }

        .results {
            display: none !important;
        }

        .sidebar.collapsed {
            width: 0px;
            /* Width when collapsed */
        }

        .pdf-viewer .toggle-btn {/* BOTAO */
            position: relative;
            top: 10px;
            right: -25px;
            margin-bottom: 10px;
            cursor: pointer;
            font-size: 20px;
            background: #2980b9;
            color: white;
            border: none;
            border-radius: 50%;
            padding: 10px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .pdf-viewer .toggle-btn:hover {
            background-color: #2980b9;
        }

        /* Beautiful Search Box */
        .search-box {
            width: 80%;
            margin: 10px auto;
            padding: 5px;
            border-radius: 25px;
            background-color: #0082fc;
         
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .search-box input {
            border: none;
            outline: none;
            width: 100%;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 14px;
            background: rgb(199, 201, 201);
            box-sizing: border-box;
        }

        .search-box button {
            background: #3498db;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            color: white;
            font-size: 14px;
            cursor: pointer;
        }

        .search-box button:hover {
            background: #2980b9;
        }

        .toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: #f4f4f4;

        }

        .toggle-btn,
        .logout-btn {
            width: 100px;
            height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            border-radius: 5px;
        }

        /* Keep their individual styles */
        .toggle-btn {
            background: none;
            border: 1px solid white;
            color: white;
            margin-right: 30px;
            /* Adds spacing between buttons */
        }

        .logout-btn {
            background: red;
            color: white;
            border: none;
            cursor: pointer;
            margin-left: 10px;
            margin-top: 10px;
        }



        .logout-btn:hover {
            background: darkred;
        }

        .sidebar.closed {
            transform: translateX(-100%);
        }
    </style>
</head>

<body>




    <div class="sidebar" id="sidebar">
        <img src="./assets/logo.png" alt="Logo" style="width: 30%; margin-left: 20px;">

        <div class="search-box">
            <input type="text" placeholder="Search..." id="searchInputcategory">
        </div>
        <details>
<summary><i class="fa-regular fa-folder icon-outline"></i>TESTE</summary>
<a href="upload/category_pdf/category_pdf1751036298.pdf" class="file"><i class="far fa-file-pdf"></i> teste</a>     
<a href="upload/category_pdf/category_pdf1750838601.pdf" class="file"><i class="far fa-file-pdf"></i> aaaaa</a>          

</details>

        <div id="loadingSpinner" class="loading-spinner"></div>
        <ul class="tree" id="categoryList"></ul>
    </div>

    <div class="pdf-viewer">
        <div class="tabs-row">
            <div id="tabHeaders">

            </div>
            <div class="toolbar">
                <button class="toggle-btn" id="toggleSidebarBtn" style="font-size: 20px;">â˜°</button>
                <button class="logout-btn" id="logoutBtn">Logout</button>
            </div>

        </div>




        <div id="pdfContainers">
            <img src="./assets/ski.jpeg" alt="Logo">
        </div>




    </div>








</body>

<script>
    $(document).ready(function () {



        $("#searchInputcategory").on("keyup", function () {
            filter = $(this).val().toLowerCase().trim();

            if (filter === "") {
                $("#categoryList li").each(function () {
                    $(this).show();
                    const $ul = $(this).children("ul");
                    if ($ul.length > 0) {
                        $ul.hide();
                        $(this).children("span").first().text("â–¶");
                    }
                });
                return;
            }

            $("#categoryList > li").each(function () {
                searchAndFilter($(this));
            });
        });










        function searchAndFilter($listItem) {
            const spans = $listItem.children("span");
            let labelText = "";

            if (spans.length === 2) {
                labelText = spans.eq(1).text().toLowerCase(); // toggle + label
            } else if (spans.length === 1) {
                labelText = spans.eq(0).text().toLowerCase(); // label only
            }

            const $childrenUl = $listItem.children("ul");
            let hasMatch = labelText.includes(filter);
            let childMatched = false;

            if ($childrenUl.length > 0) {
                $childrenUl.children("li").each(function () {
                    const $child = $(this);
                    const matched = searchAndFilter($child);

                    if (matched) {
                        $child.show();
                        childMatched = true;
                    } else {
                        // If parent category matches, don't hide children even if they don't match
                        if (hasMatch) {
                            $child.show();
                        } else {
                            $child.hide();
                        }
                    }
                });

                if (childMatched || hasMatch) {
                    $childrenUl.show();
                    $listItem.children("span").first().text("â–¼");
                } else {
                    $childrenUl.hide();
                    $listItem.children("span").first().text("â–¶");
                }
            }

            if (hasMatch || childMatched) {
                $listItem.show();
                $listItem.parents("li").each(function () {
                    $(this).show();
                    $(this).children("ul").show();
                    $(this).children("span").first().text("â–¼");
                });
                return true;
            } else {
                $listItem.hide();
                return false;
            }
        }
        // Toggle functionality for expanding/collapsing categories
        $(document).on("click", ".toggle-icon", function () {
            var childContainer = $(this).siblings("ul"); // Get the child container

            if (childContainer.is(":visible")) {
                childContainer.hide();
                $(this).text("â–¶"); // Collapsed icon
            } else {
                childContainer.show();
                $(this).text("â–¼"); // Expanded icon
            }
        });
    });
</script>


<script>
    
    // Logout Function
    document.getElementById('logoutBtn').addEventListener('click', function () {
        window.location.href = 'login.html';
    });



    // Toggle the sidebar collapse/expand
    const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
    const sidebar = document.getElementById('sidebar');

    toggleSidebarBtn.addEventListener('click', () => {
        sidebar.classList.toggle('collapsed');
    });
</script>

<script>


   function loadPDF(pdfUrl, tabId) {
    cleanupTabContent(tabId);
    const pdfContainers = document.getElementById('pdfContainers');

    if (!pdfContainers) {
        console.error('Error: #pdfContainers element not found!');
        return;
    }

    let existingContainer = document.getElementById(`pdfContainer-${tabId}`);
    if (!existingContainer) {
        existingContainer = document.createElement('div');
        existingContainer.id = `pdfContainer-${tabId}`;
        existingContainer.className = 'pdf-container';
        pdfContainers.appendChild(existingContainer);
    }

    existingContainer.innerHTML = '';

    if (!pdfUrl) {
        console.warn('No PDF URL provided');
        const message = document.createElement('p');
        message.textContent = 'No PDF available.';
        message.style.textAlign = 'center';
        message.style.color = '#ff0000';
        message.style.padding = '20px';
        existingContainer.appendChild(message);
        switchTab(tabId);
        return;
    }

    // ðŸŸ¡ Detecta se termina com .pdf
    if (pdfUrl.toLowerCase().endsWith('.pdf')) {
        // Garante formato completo se necessÃ¡rio
        pdfUrl = `viewer.html?file=${encodeURIComponent(pdfUrl)}`;
    } else {
        // Caso nÃ£o termine com .pdf, continua o comportamento padrÃ£o
        pdfUrl = `viewer.html?file=${encodeURIComponent(pdfUrl)}`;
    }

    // Mostra carregando
    const loadingIndicator = document.createElement('p');
    loadingIndicator.textContent = 'Loading PDF...';
    loadingIndicator.style.textAlign = 'center';
    loadingIndicator.style.color = '#007bff';
    loadingIndicator.style.padding = '20px';
    loadingIndicator.id = `loading-${tabId}`;
    existingContainer.appendChild(loadingIndicator);

    switchTab(tabId);

    requestAnimationFrame(() => {
        const iframe = document.createElement('iframe');
        iframe.src = pdfUrl;
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.style.display = 'none';

        iframe.onload = () => {
            console.log('PDF loaded successfully');
            loadingIndicator.remove();
            iframe.style.display = 'block';
        };

        iframe.onerror = () => {
            console.error('Error loading PDF');
            loadingIndicator.remove();
            const errorMsg = document.createElement('p');
            errorMsg.textContent = 'Error loading PDF.';
            errorMsg.style.textAlign = 'center';
            errorMsg.style.color = '#ff0000';
            existingContainer.appendChild(errorMsg);
        };

        existingContainer.appendChild(iframe);
    });
}



    function openTab(fileUrl, tabId, catname) {
        const tabHeaders = document.getElementById('tabHeaders');
        const safeTabId = String(tabId).replace(/[^a-zA-Z0-9-_]/g, '_');

        if (document.querySelector(`.tab[data-tab-id="${safeTabId}"]`)) {
            switchTab(safeTabId);
            return;
        }

        const openTabs = tabHeaders.querySelectorAll('.tab');
        if (openTabs.length >= 7) {
            alert("You can only open a maximum of 5 tabs at a time.");
            return;
        }

        const newTab = document.createElement('div');
        newTab.className = 'tab';
        newTab.setAttribute('data-tab-id', safeTabId);
        newTab.innerHTML = `${catname} <span class="close-btn" onclick="closeTab('${safeTabId}')">âœ•</span>`;
        newTab.addEventListener('click', () => switchTab(safeTabId));
        tabHeaders.appendChild(newTab);

        const extension = fileUrl.split('?')[0].split('.').pop().toLowerCase();

        if (extension === 'pdf') {
            loadPDF(`https://skillbypm.com/public/${fileUrl}`, safeTabId);
        } else if (extension === 'svg') {
            setTimeout(() => {
                loadSVG(fileUrl, safeTabId);
                //switchTab(safeTabId);
            }, 10);
        } else {
            alert('Unsupported file type');
        }
    }




    function closeTab(tabId) {
        // Remove the tab element
        const tab = document.querySelector(`.tab[data-tab-id="${tabId}"]`);
        if (tab) {
            tab.remove();
        }

        // Remove the corresponding PDF container
        const pdfContainer = document.getElementById(`pdfContainer-${tabId}`);
        if (pdfContainer) {
            pdfContainer.remove();
        }

        // Remove the closed tab from history
        const tabIndex = tabHistory.indexOf(tabId);
        if (tabIndex !== -1) {
            tabHistory.splice(tabIndex, 1);
        }

        // Switch to the last active tab (if any remain)
        if (tabHistory.length > 0) {
            const lastTabId = tabHistory[tabHistory.length - 1];
            switchTab(lastTabId);
        }
    }








    // Render Categories without re-rendering
    function renderCategories(categories, parentElement) {

        categories.sort((a, b) => a.name.localeCompare(b.name));

        categories.forEach((category) => {
            const li = document.createElement('li');
            li.setAttribute('data-name', category.name.toLowerCase());

            // Create a span for category name or PDF link
            const span = document.createElement('span');
            span.textContent = category.name;

            if (category.pdfs && category.pdfs.length > 0) {
                // Ensure the PDF icon and clickable span are rendered correctly
                span.innerHTML = `
                        <i class="bx bxs-file-pdf"></i> 
                        ${category.name}
                    `;
                span.style.cursor = 'pointer';
                span.onclick = () => openTab(category.pdfs[0].pdf, category.id, category.name);
            }

            // Create a container for children (if any)
            const childContainer = document.createElement('ul');
            childContainer.style.display = 'none'; // Initially hide children

            // If there are children, add an expand/collapse toggle
            if (category.children && category.children.length > 0) {
                const toggleIcon = document.createElement('span');
                toggleIcon.textContent = 'â–¶'; // Collapsed icon
                toggleIcon.style.cursor = 'pointer';
                toggleIcon.style.marginRight = '5px';

                // Expand/Collapse logic
                toggleIcon.addEventListener('click', () => {
                    if (childContainer.style.display === 'none') {
                        childContainer.style.display = 'block';
                        toggleIcon.textContent = 'â–¼'; // Expanded icon
                    } else {
                        childContainer.style.display = 'none';
                        toggleIcon.textContent = 'â–¶'; // Collapsed icon
                    }
                });

                li.appendChild(toggleIcon);
            }

            li.appendChild(span);

            // Recursively render children if any
            if (category.children && category.children.length > 0) {
                renderCategories(category.children, childContainer);
                li.appendChild(childContainer);
            }

            parentElement.appendChild(li);
        });
    }



    async function loadCategories() {
        const loadingSpinner = document.getElementById('loadingSpinner');
        loadingSpinner.style.display = 'block';  // Show the loading spinner inside sidebar

        try {
            const response = await fetch('https://skillbypm.com/api/categoriesmain.php');
            const data = await response.json();

            if (data.status === 'success' && data.categories.length > 0) {
                const treeContainer = document.getElementById('categoryList');
                renderCategories(data.categories, treeContainer);
            } else {
                console.error('No categories available or error fetching categories:', data.message);
                const treeContainer = document.getElementById('categoryList');
                treeContainer.innerHTML = '<li>No categories available</li>';
            }
        } catch (error) {
            console.error('Network error:', error);
            const treeContainer = document.getElementById('categoryList');
            treeContainer.innerHTML = '<li>Error loading categories. Please try again later.</li>';
        } finally {
            loadingSpinner.style.display = 'none';  // Hide the loading spinner after data is loaded
        }
    }


    //http://127.0.0.1:8000/api/bitmap-data


   async function loadBitmaps() {
    const treeContainer = document.getElementById('categoryList');
    treeContainer.innerHTML = '';

    const bitmapsContainer = document.createElement('li');
    const rootToggleIcon = document.createElement('span');
    rootToggleIcon.textContent = 'â–¶';
    rootToggleIcon.style.cursor = 'pointer';
    rootToggleIcon.style.marginRight = '5px';

    const rootLabel = document.createElement('span');
    rootLabel.textContent = 'Bitmaps'.toUpperCase();

    const bitmapList = document.createElement('ul');
    bitmapList.style.display = 'none';

    rootToggleIcon.addEventListener('click', () => {
        const isVisible = bitmapList.style.display === 'block';
        bitmapList.style.display = isVisible ? 'none' : 'block';
        rootToggleIcon.textContent = isVisible ? 'â–¶' : 'â–¼';
    });

    bitmapsContainer.appendChild(rootToggleIcon);
    bitmapsContainer.appendChild(rootLabel);

    try {
        const response = await fetch('https://bitmap.skillbypm.com/api/bitmap-data');
        const data = await response.json();

        if (data.success && data.categories.length > 0) {
            data.categories.forEach(category => {
                const categoryLi = document.createElement('li');

                const categoryToggle = document.createElement('span');
                categoryToggle.textContent = 'â–¶';
                categoryToggle.style.cursor = 'pointer';
                categoryToggle.style.marginRight = '5px';

                const categoryLabel = document.createElement('span');
                categoryLabel.textContent = category.name;

                const modelList = document.createElement('ul');
                modelList.style.display = 'none';

                categoryToggle.addEventListener('click', () => {
                    const isVisible = modelList.style.display === 'block';
                    modelList.style.display = isVisible ? 'none' : 'block';
                    categoryToggle.textContent = isVisible ? 'â–¶' : 'â–¼';
                });

                categoryLi.appendChild(categoryToggle);
                categoryLi.appendChild(categoryLabel);

                if (category.subcategories && category.subcategories.length > 0) {
                    category.subcategories.forEach(subcategory => {
                        const modelLi = document.createElement('li');

                        const span = document.createElement('span');
                        span.textContent = subcategory.name;
                        span.style.cursor = 'default';

                        if (subcategory.file_path) {
                            // Cria o Ã­cone SVG
                            const svgIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                            svgIcon.setAttribute("width", "16");
                            svgIcon.setAttribute("height", "16");
                            svgIcon.setAttribute("viewBox", "0 0 24 24");
                            svgIcon.setAttribute("fill", "none");
                            svgIcon.setAttribute("stroke", "currentColor");
                            svgIcon.setAttribute("stroke-width", "2");
                            svgIcon.setAttribute("stroke-linecap", "round");
                            svgIcon.setAttribute("stroke-linejoin", "round");
                            svgIcon.style.marginRight = "6px";
                            svgIcon.style.verticalAlign = "middle";
                            svgIcon.style.cursor = "pointer";

                            const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
                            path1.setAttribute("d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
                            const path2 = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
                            path2.setAttribute("points", "14 2 14 8 20 8");

                            svgIcon.appendChild(path1);
                            svgIcon.appendChild(path2);

                            // Tooltip
                            const tooltip = document.createElement('span');
                            tooltip.style.position = 'absolute';
                            tooltip.style.background = 'rgba(0,0,0,0.8)';
                            tooltip.style.color = '#fff';
                            tooltip.style.padding = '4px 8px';
                            tooltip.style.borderRadius = '4px';
                            tooltip.style.fontSize = '12px';
                            tooltip.style.whiteSpace = 'nowrap';
                            tooltip.style.zIndex = '10000';
                            tooltip.style.display = 'none';
                            tooltip.style.pointerEvents = 'none';
                            document.body.appendChild(tooltip);

                            const openSvg = (e) => {
                                navigator.clipboard.writeText(subcategory.file_path).catch(err => {
                                    console.error("Erro ao copiar a URL:", err);
                                });
                                openTab(subcategory.file_path, subcategory.id, subcategory.name);
                            };

                            [svgIcon, span].forEach(el => {
                                el.addEventListener('mouseenter', (e) => {
                                    tooltip.textContent = subcategory.file_path;
                                    tooltip.style.left = e.pageX + 10 + 'px';
                                    tooltip.style.top = e.pageY + 10 + 'px';
                                    tooltip.style.display = 'block';
                                });
                                el.addEventListener('mousemove', (e) => {
                                    tooltip.style.left = e.pageX + 10 + 'px';
                                    tooltip.style.top = e.pageY + 10 + 'px';
                                });
                                el.addEventListener('mouseleave', () => {
                                    tooltip.style.display = 'none';
                                });
                                el.addEventListener('click', openSvg);
                                el.style.cursor = "pointer";
                            });

                            modelLi.appendChild(svgIcon);
                            modelLi.appendChild(span);
                        } else {
                            modelLi.appendChild(span);
                        }

                        modelList.appendChild(modelLi);
                    });
                } else {
                    const emptyModelLi = document.createElement('li');
                    emptyModelLi.textContent = 'No subcategories';
                    modelList.appendChild(emptyModelLi);
                }

                categoryLi.appendChild(modelList);
                bitmapList.appendChild(categoryLi);
            });
        } else {
            bitmapList.innerHTML = '<li>No bitmap categories available</li>';
        }

    } catch (error) {
        console.error('Error loading bitmaps:', error);
        bitmapList.innerHTML = '<li>Error loading bitmaps.</li>';
    }

    bitmapsContainer.appendChild(bitmapList);
    treeContainer.appendChild(bitmapsContainer);
}



    function updateTransform() {
        if (!svgElement) {
            console.warn("svgElement is null, can't update transform");
            return;
        }
        svgElement.style.transform = `translate(${translate.x}px, ${translate.y}px) scale(${scale})`;
        svgElement.style.transformOrigin = '0 0';  // or 'center'
    }

    function handleWheel(e) {
        e.preventDefault();
        const zoomFactor = 0.30;
        const delta = e.deltaY > 0 ? 1 - zoomFactor : 1 + zoomFactor;

        const proposedScale = scale * delta;
        const minScale = 0.4;
        const maxScale = 160;

        const newScale = Math.min(Math.max(proposedScale, minScale), maxScale);

        if (newScale === scale) return;

        const rect = svgElement.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        const offsetY = e.clientY - rect.top;

        translate.x -= offsetX * (newScale - scale) / scale;
        translate.y -= offsetY * (newScale - scale) / scale;

        scale = newScale;
        updateTransform();
    }

    function handleMouseDown(e) {
        isPanning = true;
        panStart = { x: e.clientX, y: e.clientY };
        mouseMoved = false;
    }



    function handleMouseUp(e) {
        isPanning = false;
    }

    function handleMouseMove(e) {
        if (!isPanning) return;

        const dx = e.clientX - panStart.x;
        const dy = e.clientY - panStart.y;

        if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
            mouseMoved = true;
        }

        const dampening = 0.5;
        translate.x += dx * dampening;
        translate.y += dy * dampening;

        panStart = { x: e.clientX, y: e.clientY };
        updateTransform();
    }

    function cleanupTabContent(tabId) {
        const container = document.getElementById(`pdfContainer-${tabId}`);
        if (container) container.innerHTML = '';

        if (tabState[tabId]?.listeners) {
            tabState[tabId].listeners.forEach(({ el, type, fn }) => {
                el.removeEventListener(type, fn);
            });
        }

        delete tabState[tabId];
    }

    const tabState = {};
    const tabHistory = [];
    let activeTabId = null;

    function loadSVG(svgUrl, tabId) {
        cleanupTabContent(tabId);
        const pdfContainers = document.getElementById('pdfContainers');

        if (!pdfContainers) {
            console.error('Error: #pdfContainers element not found!');
            return;
        }

        let existingContainer = document.getElementById(`pdfContainer-${tabId}`);
        if (!existingContainer) {
            existingContainer = document.createElement('div');
            existingContainer.id = `pdfContainer-${tabId}`;
            existingContainer.className = 'pdf-container';
            pdfContainers.appendChild(existingContainer);
        }

        existingContainer.innerHTML = '';

        if (!svgUrl) {
            console.warn('No SVG URL provided');
            const message = document.createElement('p');
            message.textContent = 'No SVG available.';
            message.style.textAlign = 'center';
            message.style.color = '#ff0000';
            message.style.padding = '20px';
            existingContainer.appendChild(message);
            switchTab(tabId);
            return;
        }

        // Show loading indicator
        const loadingIndicator = document.createElement('p');
        loadingIndicator.textContent = 'Loading SVG...';
        loadingIndicator.style.textAlign = 'center';
        loadingIndicator.style.color = '#007bff';
        loadingIndicator.style.padding = '20px';
        loadingIndicator.id = `loading-${tabId}`;
        existingContainer.appendChild(loadingIndicator);

        switchTab(tabId); // Show tab immediately

        requestAnimationFrame(() => {
            const iframe = document.createElement('iframe');
            iframe.src = `svg-viewer.html?file=${encodeURIComponent(svgUrl)}&tabId=${encodeURIComponent(tabId)}`;
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.style.display = 'none';

            iframe.onload = () => {
                console.log('SVG loaded successfully');
                loadingIndicator.remove();
                iframe.style.display = 'block';
            };

            iframe.onerror = () => {
                console.error('Error loading SVG');
                loadingIndicator.remove();
                const errorMsg = document.createElement('p');
                errorMsg.textContent = 'Error loading SVG.';
                errorMsg.style.textAlign = 'center';
                errorMsg.style.color = '#ff0000';
                existingContainer.appendChild(errorMsg);
            };

            existingContainer.appendChild(iframe);
        });
    }












    function switchTab(tabId) {
        activeTabId = tabId;
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        const activeTab = document.querySelector(`.tab[data-tab-id="${tabId}"]`);
        if (activeTab) activeTab.classList.add('active');

        document.querySelectorAll('.pdf-container').forEach(container => container.style.display = 'none');

        const target = document.getElementById(`pdfContainer-${tabId}`);
        if (target) {
            target.style.display = 'block';

            // ðŸ§¼ Clean SVG overlays when switching
            const svg = target.querySelector('svg');
            if (svg) {
                svg.querySelectorAll('.highlighted-overlay, .link-line, .selected').forEach(el => el.remove());
            }
        }
    }

    function handleComponentClick(componentId, componentsList, svg) {
        svg.querySelectorAll('.highlighted-overlay').forEach(el => el.remove());
        const clickedComponent = componentsList.find(c => c.component === componentId);
        if (!clickedComponent) return;

        //console.log(clickedComponent);
        const netName = clickedComponent.netName; // or clickedComponent.netname if exists

        // Get all components with the same net name
        const relatedComponents = componentsList.filter(c => c.netName === netName);

        console.log(relatedComponents);
        // Extract coordinates
        const points = relatedComponents.map(c => {
            const [xPart, yPart] = c.component.split('_');
            const x = parseInt(xPart.replace('x', ''));
            const y = parseInt(yPart.replace('y', ''));
            return {
                x,
                y,
                target: c.target || ''
            };
        });

        drawConnectionLine(points, svg);

        const tableBody = document.getElementById('rightBarTableBody');
        tableBody.innerHTML = ''; // Clear existing rows

        relatedComponents.forEach(component => {
            const tr = document.createElement('tr');

            const netCell = document.createElement('td');
            netCell.textContent = component.netName || '-';

            const footprintCell = document.createElement('td');
            footprintCell.textContent = component.footprint || '-';

            const pinCell = document.createElement('td');
            pinCell.textContent = component.pin || '-';

            tr.appendChild(netCell);
            tr.appendChild(footprintCell);
            tr.appendChild(pinCell);

            tableBody.appendChild(tr);
        });
    }


    function drawConnectionLine(points, svg) {
        if (!points || points.length < 2) {
            console.warn('Not enough points to draw a connection.');
            return;
        }

        //const svg = document.querySelector('#svg-container svg');
        if (!svg) {
            console.error('SVG element not found inside #svg-container');
            return;
        }

        // Cleanup previous highlights and lines
        svg.querySelectorAll('.link-line').forEach(line => line.remove());
        svg.querySelectorAll('.highlighted-overlay').forEach(el => el.remove());

        const tolerance = 2;
        const centers = [];

        points.forEach(p => {
            if (!p.target) return;

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = p.target.trim();
            const targetEl = tempDiv.firstChild;
            if (!targetEl) return;

            const tagName = targetEl.tagName.toLowerCase();

            if (tagName === 'rect') {
                const tx = parseFloat(targetEl.getAttribute('x'));
                const ty = parseFloat(targetEl.getAttribute('y'));
                const tw = parseFloat(targetEl.getAttribute('width'));
                const th = parseFloat(targetEl.getAttribute('height'));

                if (!isNaN(tx) && !isNaN(ty) && !isNaN(tw) && !isNaN(th)) {
                    const center = {
                        x: tx + tw / 2,
                        y: ty + th / 2
                    };
                    centers.push(center);

                    const match = Array.from(svg.querySelectorAll('rect')).find(r => {
                        const rx = parseFloat(r.getAttribute('x'));
                        const ry = parseFloat(r.getAttribute('y'));
                        const rw = parseFloat(r.getAttribute('width'));
                        const rh = parseFloat(r.getAttribute('height'));
                        return (
                            Math.abs(rx - tx) < tolerance &&
                            Math.abs(ry - ty) < tolerance &&
                            Math.abs(rw - tw) < tolerance &&
                            Math.abs(rh - th) < tolerance
                        );
                    });

                    if (match) {
                        const overlay = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        overlay.setAttribute("x", tx);
                        overlay.setAttribute("y", ty);
                        overlay.setAttribute("width", tw);
                        overlay.setAttribute("height", th);
                        overlay.setAttribute("rx", 8);
                        overlay.setAttribute("fill", "rgba(0, 128, 0, 0.6)");
                        overlay.setAttribute("stroke", "#00c853");
                        overlay.setAttribute("stroke-width", "2");
                        overlay.setAttribute("pointer-events", "none");
                        overlay.classList.add("highlighted-overlay");
                        svg.appendChild(overlay);
                    }
                }

            } else if (tagName === 'circle') {
                const cx = parseFloat(targetEl.getAttribute('cx'));
                const cy = parseFloat(targetEl.getAttribute('cy'));
                const r = parseFloat(targetEl.getAttribute('r'));

                if (!isNaN(cx) && !isNaN(cy) && !isNaN(r)) {
                    const center = {
                        x: cx,
                        y: cy
                    };
                    centers.push(center);

                    const match = Array.from(svg.querySelectorAll('circle')).find(c => {
                        const ccx = parseFloat(c.getAttribute('cx'));
                        const ccy = parseFloat(c.getAttribute('cy'));
                        const cr = parseFloat(c.getAttribute('r'));
                        return (
                            Math.abs(ccx - cx) < tolerance &&
                            Math.abs(ccy - cy) < tolerance &&
                            Math.abs(cr - r) < tolerance
                        );
                    });

                    if (match) {
                        const overlay = document.createElementNS("http://www.w3.org/2000/svg",
                            "circle");
                        overlay.setAttribute("cx", cx);
                        overlay.setAttribute("cy", cy);
                        overlay.setAttribute("r", r);
                        overlay.setAttribute("fill", "rgba(0, 128, 0, 0.6)");
                        overlay.setAttribute("stroke", "#00c853");
                        overlay.setAttribute("stroke-width", "2");
                        overlay.setAttribute("pointer-events", "none");
                        overlay.classList.add("highlighted-overlay");
                        svg.appendChild(overlay);
                    }
                }

            } else if (tagName === 'ellipse') {
                const cx = parseFloat(targetEl.getAttribute('cx'));
                const cy = parseFloat(targetEl.getAttribute('cy'));
                const rx = parseFloat(targetEl.getAttribute('rx'));
                const ry = parseFloat(targetEl.getAttribute('ry'));

                if (!isNaN(cx) && !isNaN(cy) && !isNaN(rx) && !isNaN(ry)) {
                    const center = {
                        x: cx,
                        y: cy
                    };
                    centers.push(center);

                    const match = Array.from(svg.querySelectorAll('ellipse')).find(e => {
                        const ecx = parseFloat(e.getAttribute('cx'));
                        const ecy = parseFloat(e.getAttribute('cy'));
                        const erx = parseFloat(e.getAttribute('rx'));
                        const ery = parseFloat(e.getAttribute('ry'));
                        return (
                            Math.abs(ecx - cx) < tolerance &&
                            Math.abs(ecy - cy) < tolerance &&
                            Math.abs(erx - rx) < tolerance &&
                            Math.abs(ery - ry) < tolerance
                        );
                    });

                    if (match) {
                        const overlay = document.createElementNS("http://www.w3.org/2000/svg",
                            "ellipse");
                        overlay.setAttribute("cx", cx);
                        overlay.setAttribute("cy", cy);
                        overlay.setAttribute("rx", rx);
                        overlay.setAttribute("ry", ry);
                        overlay.setAttribute("fill", "rgba(0, 128, 0, 0.6)");
                        overlay.setAttribute("stroke", "#00c853");
                        overlay.setAttribute("stroke-width", "2");
                        overlay.setAttribute("pointer-events", "none");
                        overlay.classList.add("highlighted-overlay");
                        svg.appendChild(overlay);
                    }
                }
            }
        });

        console.warn(`Total points: ${points.length}, Valid centers: ${centers.length}`);
        console.log('Centers:', centers);

        if (centers.length < 2) {
            console.warn('Less than 2 usable centers. Cannot draw line.');
            return;
        }

        centers.sort((a, b) => a.x - b.x);

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let d = `M ${centers[0].x} ${centers[0].y}`;
        let currentX = centers[0].x;
        let currentY = centers[0].y;

        for (let i = 1; i < centers.length; i++) {
            const target = centers[i];
            const midX = (currentX + target.x) / 2;

            d += ` L ${midX} ${currentY}`;
            d += ` L ${midX} ${target.y}`;
            d += ` L ${target.x} ${target.y}`;

            currentX = target.x;
            currentY = target.y;
        }

        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', 'limegreen');
        path.setAttribute('stroke-width', '8');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-opacity', '0.7');
        path.setAttribute('filter', 'url(#glow)');
        path.classList.add('link-line');

        svg.appendChild(path);
    }


    function setupComponentsText(allComponents, svg) {


        // const svgContainer = document.getElementById('svg-container');
        // const svgElement1 = svgContainer.querySelector('svg');

        const svgElement1 = svg;

        // âœ… Create rectangles for each dynamic component
        allComponents.forEach((comp1, index) => {
            const coords = parseComponentCoordinates(comp1.component_location);
            if (!coords) return;

            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");

            rect.setAttribute("x", coords.x);
            rect.setAttribute("y", coords.y);
            rect.setAttribute("width", coords.width);
            rect.setAttribute("height", coords.height);
            rect.setAttribute("fill", "transparent"); // transparent fill
            rect.style.cursor = "pointer";
            rect.setAttribute("rx", 10);
            rect.setAttribute("stroke", "white");
            rect.setAttribute("stroke-width", 2);
            rect.setAttribute("fill", "none");

            const tick = document.createElementNS("http://www.w3.org/2000/svg", "text");

            // Optionally trim text if itâ€™s too long (optional step)
            function trimTextToFit(text, maxChars) {
                return text.length > maxChars ? text.substring(0, maxChars - 3) + "..." : text;
            }
            const maxChars = Math.floor(coords.width / 8); // tweak divisor as needed
            const textToDisplay = trimTextToFit(comp1.component_name, maxChars);

            tick.textContent = textToDisplay;
            tick.setAttribute("fill", "rgba(255, 255, 255, 0.6)");
            tick.setAttribute("font-weight", "bold");
            tick.style.pointerEvents = "none"; // already included
            tick.style.userSelect = "none";
            tick.style.webkitUserSelect = "none";
            tick.style.mozUserSelect = "none";
            tick.style.msUserSelect = "none";
            // Estimate font size dynamically based on width and text length
            const textLength = textToDisplay.length;
            const maxWidth = coords.width * 0.9;
            let fontSize = Math.min(coords.width, coords.height) * 0.3;
            const estimatedCharWidth = fontSize * 0.6;
            const estimatedTextWidth = textLength * estimatedCharWidth;

            if (estimatedTextWidth > maxWidth) {
                fontSize = maxWidth / (textLength * 0.6);
            }
            tick.setAttribute("font-size", fontSize);

            // Center the tick inside the rect
            const centerX = coords.x + coords.width / 2;
            const centerY = coords.y + coords.height / 2;
            tick.setAttribute("text-anchor", "middle");
            tick.setAttribute("dominant-baseline", "middle");

            if (coords.height > coords.width) {
                // Box is vertical: rotate text 90 degrees
                tick.setAttribute("transform", `rotate(90, ${centerX}, ${centerY})`);
                tick.setAttribute("x", centerX);
                tick.setAttribute("y", centerY);
            } else {
                // Normal horizontal text
                tick.setAttribute("x", centerX);
                tick.setAttribute("y", centerY);
            }


            svgElement1.appendChild(rect);
            svgElement1.appendChild(tick);
        });
    }

    function generateComponentIdFromCoords(target) {
        const bbox = target.getBBox();
        // Example ID: "x10_y20_w100_h50"
        return `x${Math.round(bbox.x)}_y${Math.round(bbox.y)}_w${Math.round(bbox.width)}_h${Math.round(bbox.height)}`;
    }





    function highlightSelectedElement(target) {

        // console.log(target);
        // Remove highlight and blinking animation from previous selection
        document.querySelectorAll('svg *').forEach(el => {
            el.style.fill = '';
            el.style.stroke = '';
            el.style.strokeWidth = '';
            el.style.filter = '';
            el.style.transition = '';
            el.style.animation = '';
        });

        // Define blinking animation using CSS keyframes via JavaScript
        const styleSheetId = 'highlight-blink-style';
        if (!document.getElementById(styleSheetId)) {
            const styleSheet = document.createElement('style');
            styleSheet.id = styleSheetId;
            styleSheet.type = 'text/css';
          
            document.head.appendChild(styleSheet);
        }

        // Apply blinking animation and static styles
        target.style.stroke = '#00bfff'; // bright cyan-blue
        target.style.strokeWidth = '20px'; // thick stroke
        target.style.filter = 'drop-shadow(0 0 8px #00bfff)'; // glowing effect
        target.style.transition = 'stroke 0.3s ease, stroke-width 0.3s ease, filter 0.3s ease';

        // Apply the blinking animation (2 seconds infinite)
        target.style.animation = 'blinkGlow 2s infinite';
    }


    function setupComponents(components, svg) {
        // const svgContainer = document.getElementById('svg-container');
        // const svgElement = svgContainer.querySelector('svg');

        const svgElement = svg;

        // Tooltip setup
        const tooltip = document.createElement('div');
        Object.assign(tooltip.style, {
            position: 'absolute',
            padding: '10px 16px',
            background: 'rgba(23, 177, 105, 0.85)',
            color: '#fff',
            borderRadius: '10px',
            boxShadow: '0 4px 12px rgba(0, 0, 0, 0.25)',
            pointerEvents: 'none',
            fontSize: '14px',
            fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
            whiteSpace: 'normal',
            lineHeight: '1.5',
            zIndex: 1000,
            display: 'none',
            textAlign: 'center',
            width: '260px',
            maxWidth: '420px',
            transition: 'opacity 0.2s ease, transform 0.2s ease'
        });
        document.body.appendChild(tooltip);

        const compMap = new Map();
        const tooltipCache = new Map();
        components.forEach(comp => {
            compMap.set(comp.component, comp);
        });

        const BATCH_SIZE = 300;
        let currentIndex = 0;

        function renderBatch() {
            const frag = document.createDocumentFragment();

            for (let i = 0; i < BATCH_SIZE && currentIndex < components.length; i++, currentIndex++) {
                const comp = components[currentIndex];
                const coords = parseComponentCoordinates(comp.component);
                if (!coords) continue;

                const {
                    x,
                    y,
                    width,
                    height
                } = coords;
                const centerX = x + width / 2;
                const centerY = y + height / 2; // âœ… FIXED

                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute("x", x);
                rect.setAttribute("y", y);
                rect.setAttribute("width", width);
                rect.setAttribute("height", height);
                rect.setAttribute("fill", "transparent");
                rect.setAttribute("rx", 10);
                rect.style.cursor = "pointer";
                rect.dataset.componentId = comp.component;
                frag.appendChild(rect);

                const tick = document.createElementNS("http://www.w3.org/2000/svg", "text");
                tick.setAttribute("x", centerX);
                tick.setAttribute("y", centerY);
                tick.setAttribute("fill", "black");
                tick.setAttribute("text-anchor", "middle");
                tick.setAttribute("dominant-baseline", "middle");
                tick.setAttribute("xml:space", "preserve");

                // Prevent user from selecting or interacting with the text
                tick.style.pointerEvents = "none";
                tick.style.userSelect = "none";
                tick.style.webkitUserSelect = "none";
                tick.style.mozUserSelect = "none";
                tick.style.msUserSelect = "none";

                // Calculate optimal font size based on rect size and text length
                const lines = [comp.netName].filter(Boolean);
                const textLength = Math.max(...lines.map(line => line.length));
                let fontSize = Math.min(width, height) * 0.1;
                const estimatedCharWidth = fontSize * 0.6;
                const estimatedTextWidth = textLength * estimatedCharWidth;
                const maxWidth = width * 0.9;

                if (estimatedTextWidth > maxWidth) {
                    fontSize = maxWidth / (textLength * 0.4);
                }
                tick.setAttribute("font-size", fontSize);

                // Add lines using tspans for better control
                const lineHeight = fontSize * 1.2;
                const totalHeight = lines.length * lineHeight;
                const startYOffset = -((lines.length - 1) / 2) * lineHeight;

                lines.forEach((line, index) => {
                    const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
                    tspan.setAttribute("x", centerX);
                    tspan.setAttribute("dy", index === 0 ? startYOffset : lineHeight);
                    tspan.textContent = line;
                    tick.appendChild(tspan);
                });

                frag.appendChild(tick);

                // Cache tooltip content ahead of time (optional but boosts hover speed)
                tooltipCache.set(comp.component, `
                <div style="font-weight: 600; margin-bottom: 6px;">Component: ${comp.name}</div>
                <div><strong>Net Name:</strong> ${comp.netName}</div>
                <div><strong>Footprint:</strong> ${comp.footprint}</div>
                <div><strong>Pin Number:</strong> ${comp.pinNumber}</div>
                <div><strong>Comment:</strong> ${comp.comment}</div>
                <div><strong>Diode Value:</strong> ${comp.diodeValue}</div>
                <div><strong>Capacitor Value:</strong> ${comp.capacitorValue}</div>
                <div><strong>Voltage Value:</strong> ${comp.voltageValue}</div>
                <div><strong>Ohm Value:</strong> ${comp.ohmValue}</div>
            `);
            }

            svgElement.appendChild(frag);

            if (currentIndex < components.length) {
                requestIdleCallback(renderBatch);
            }
        }

        renderBatch();

        // Throttle mousemove updates
        let lastMove = 0;
        svgElement.addEventListener('mousemove', (e) => {
            const now = performance.now();
            if (now - lastMove > 16) { // ~60fps
                tooltip.style.left = e.pageX + 10 + 'px';
                tooltip.style.top = e.pageY + 10 + 'px';
                lastMove = now;
            }
        });

        // Tooltip hover (delegated)
        svgElement.addEventListener('mouseover', (e) => {
            const rect = e.target.closest('rect[data-component-id]');
            if (!rect) return;

            const compId = rect.dataset.componentId;
            const html = tooltipCache.get(compId);
            if (!html) return;

            tooltip.innerHTML = html;
            tooltip.style.display = 'block';

            rect.addEventListener('mouseout', () => {
                tooltip.style.display = 'none';
            }, {
                once: true
            });
        });
    }




    function parseComponentCoordinates(componentStr) {
        const regex = /x(\d+)_y(\d+)_w(\d+)_h(\d+)/;
        const match = componentStr.match(regex);
        if (!match) return null;
        return {
            x: parseInt(match[1], 10),
            y: parseInt(match[2], 10),
            width: parseInt(match[3], 10),
            height: parseInt(match[4], 10),
        };
    }



    // Load categories on page load
    document.addEventListener('DOMContentLoaded', () => {
        const spinner = document.getElementById('loadingSpinner');
        if (spinner) spinner.style.display = 'block'; // Show spinner initially

        // Start loading both simultaneously, but handle their results separately
        const loadCats = loadCategories().then(() => {
            console.log('Categories loaded');
        }).catch(err => console.error('Categories failed:', err));

        const loadBits = loadBitmaps().then(() => {
            console.log('Bitmaps loaded');
        }).catch(err => console.error('Bitmaps failed:', err));

        // Wait for both to finish, then hide spinner
        Promise.all([loadCats, loadBits]).finally(() => {
            if (spinner) spinner.style.display = 'none';
        });
    });




</script>





<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  // ðŸŸ¦ BOTÃ•ES E BARRA DE PROGRESSO
  const downloadBtn = document.createElement("button");
  downloadBtn.textContent = "â¬‡ï¸ Baixar MOBILE SOLUTION";
  downloadBtn.style.right = "20px";

  const clearBtn = document.createElement("button");
  clearBtn.textContent = "ðŸ—‘ Limpar HistÃ³rico";
  clearBtn.style.right = "260px";
  clearBtn.style.background = "#dc3545";

  const progressBar = document.createElement("div");
  const progressInner = document.createElement("div");

  Object.assign(progressBar.style, {
    position: "fixed",
    bottom: "70px",
    right: "20px",
    width: "300px",
    height: "20px",
    background: "#ddd",
    borderRadius: "10px",
    overflow: "hidden",
    zIndex: "9999"
  });
  Object.assign(progressInner.style, {
    width: "0%",
    height: "100%",
    background: "#28a745"
  });

  progressBar.appendChild(progressInner);
  document.body.append(downloadBtn, clearBtn, progressBar);

  const style = document.createElement("style");
  style.textContent = `
    button {
      position: fixed;
      bottom: 20px;
      background: #007bff;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      border: none;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 9999;
    }
    button:hover { background: #0056b3; transform: scale(1.05); }
    #clearBtn:hover { background: #a71d2a; }
  `;
  document.head.appendChild(style);

  // ðŸŸ¨ VARIÃVEIS GLOBAIS
  let downloadedList = JSON.parse(localStorage.getItem("mobile_solution_downloaded")) || [];
  let totalPdfs = 0;
  let downloadedCount = downloadedList.length;
  let downloadQueue = [];
  let currentIndex = 0;
  let isDownloading = false;
  let rootHandle = null;

  // ðŸŸ© ATUALIZAÃ‡ÃƒO DA BARRA
  function updateProgress() {
    const percent = totalPdfs ? Math.round((downloadedCount / totalPdfs) * 100) : 0;
    progressInner.style.width = percent + "%";
    downloadBtn.textContent = isDownloading
      ? `â³ Baixando... ${downloadedCount}/${totalPdfs}`
      : `â¬‡ï¸ Baixar MOBILE SOLUTION (${downloadedCount}/${totalPdfs})`;
  }

  // ðŸŸ§ LOCALIZA O NÃ“ "MOBILE SOLUTION"
  function findSolutionNode(nodes) {
    for (const node of nodes) {
      if ((node.name || node.nome || "").toUpperCase().includes("MOBILE SOLUTION")) return node;
      const children = (node.children || []).concat(node.crianÃ§as || []);
      const found = findSolutionNode(children);
      if (found) return found;
    }
    return null;
  }

  // ðŸŸ¦ CONTA TODOS OS PDFs
  function countAllPdfs(node) {
    let count = 0;
    if (node.pdf) count++;
    if (node.pdfs && Array.isArray(node.pdfs)) {
      for (const p of node.pdfs) if (p && p.pdf) count++;
    }
    const children = (node.children || []).concat(node.crianÃ§as || []);
    for (const child of children) count += countAllPdfs(child);
    return count;
  }

  // ðŸŸ¨ MONTA A LISTA DE DOWNLOADS
  function buildDownloadQueue(node, path = "") {
    const folderPath = path + (node.name || node.nome || "Sem_Nome") + "/";
    const pdfsList = [];

    if (node.pdf) pdfsList.push({ path: folderPath, file: node.pdf });
    if (node.pdfs && Array.isArray(node.pdfs)) {
      for (const p of node.pdfs) if (p && p.pdf) pdfsList.push({ path: folderPath, file: p.pdf });
    }

    const children = (node.children || []).concat(node.crianÃ§as || []);
    for (const child of children) pdfsList.push(...buildDownloadQueue(child, folderPath));

    return pdfsList;
  }

  // ðŸŸ© GARANTE QUE AS PASTAS EXISTAM
  async function ensureFolder(path) {
    const parts = path.split("/").filter(Boolean);
    let current = rootHandle;
    for (const part of parts) {
      current = await current.getDirectoryHandle(part, { create: true });
    }
    return current;
  }

  // ðŸŸ¥ ETAPA DE DOWNLOAD
  async function downloadStep() {
    if (currentIndex >= downloadQueue.length) {
      isDownloading = false;
      updateProgress();
      alert("âœ… Todos os arquivos disponÃ­veis foram baixados!");
      return;
    }

    const item = downloadQueue[currentIndex];

    if (!downloadedList.includes(item.file)) {
      try {
        const url = `https://skillbypm.com/public/${item.file.replace(/\s/g, '')}`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(resp.status);
        const blob = await resp.blob();

        const folder = await ensureFolder(item.path);
        const fileName = item.file.split("/").pop();

        const fileHandle = await folder.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(blob);
        await writable.close();

        downloadedList.push(item.file);
        localStorage.setItem("mobile_solution_downloaded", JSON.stringify(downloadedList));
        downloadedCount++;
        console.log(`ðŸ“„ Salvo em: ${item.path}${fileName}`);
        updateProgress();
      } catch (e) {
        console.error("âš ï¸ Erro ao baixar:", item.path + item.file, e);
      }
    } else {
      console.log(`âœ… JÃ¡ baixado: ${item.path}${item.file.split("/").pop()}`);
      downloadedCount++;
      updateProgress();
    }

    currentIndex++;
    setTimeout(downloadStep, 50);
  }

  // ðŸŸ© BOTÃƒO DE DOWNLOAD
  downloadBtn.addEventListener("click", async () => {
    if (!isDownloading) {
      downloadBtn.disabled = true;
      isDownloading = true;
      downloadBtn.textContent = "â³ Preparando...";

      try {
        const response = await fetch("https://skillbypm.com/api/categoriesmain.php");
        const data = await response.json();
        const rootNode = findSolutionNode(data.categories || []);
        if (!rootNode) {
          alert("âŒ Nenhuma pasta 'MOBILE SOLUTION' encontrada");
          downloadBtn.disabled = false;
          isDownloading = false;
          return;
        }

        rootHandle = await window.showDirectoryPicker();
        downloadQueue = buildDownloadQueue(rootNode);
        totalPdfs = countAllPdfs(rootNode);
        downloadedCount = downloadedList.length;
        updateProgress();
        currentIndex = 0;
        downloadStep();
      } catch (e) {
        console.error("Erro geral:", e);
        alert("âŒ Erro ao iniciar download");
        downloadBtn.disabled = false;
        isDownloading = false;
      }
    }
  });

  // ðŸ§¹ BOTÃƒO LIMPAR HISTÃ“RICO
  clearBtn.addEventListener("click", () => {
    if (confirm("Deseja realmente limpar o histÃ³rico de downloads?")) {
      localStorage.removeItem("mobile_solution_downloaded");
      downloadedList = [];
      downloadedCount = 0;
      totalPdfs = 0;
      downloadQueue = [];
      currentIndex = 0;
      isDownloading = false;
      updateProgress();
      alert("âœ… HistÃ³rico limpo!");
    }
  });

  updateProgress();
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.body.addEventListener('click', (event) => {
    const link = event.target.closest('a.file');
    if (!link) return;

    const href = link.getAttribute('href');
    if (!href) return;

    // Detecta se Ã© PDF
    if (href.toLowerCase().endsWith('.pdf')) {
      event.preventDefault();

      // Cria um ID seguro baseado no nome do arquivo
      const safeTabId = href.split('/').pop().replace(/\.pdf$/i, '').replace(/[^a-zA-Z0-9-_]/g, '_');

      // O nome da categoria (ex: DJI RC PLUS)
      const catSummary = link.closest('details')?.querySelector('summary')?.textContent.trim() || 'PDF';

      // Chama openTab() â€” que jÃ¡ cria e ativa a aba
      openTab(href, safeTabId, catSummary);
    }
  });
});
</script>


</html>